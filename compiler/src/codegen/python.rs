use crate::codegen::framework::{Framework, FrameworkSelector};
use crate::codegen::traits::{CodeGenerator, CodegenConfig, TargetLanguage};
use crate::compiler::language::VELISCH_FINGERPRINT;
use crate::parser::ast::*;

pub struct PythonCodeGenerator {
    output: String,
    indent_level: usize,
    framework: Framework,
    routes: Vec<(String, String, String)>,
}

impl CodeGenerator for PythonCodeGenerator {
    fn generate(&mut self, program: &Program, config: &CodegenConfig) -> anyhow::Result<String> {
        self.output.clear();
        self.indent_level = 0;
        self.routes.clear();

        // Detect framework
        let framework = FrameworkSelector::detect_framework(program, config.framework.as_deref());
        self.framework = framework;

        self.writeln("#!/usr/bin/env python3");
        self.writeln(&format!("# {}", VELISCH_FINGERPRINT));
        self.writeln("# Generated by VelinScript Compiler");
        self.writeln("");

        // Framework imports
        self.writeln(&FrameworkSelector::generate_imports(framework));

        self.writeln("from dataclasses import dataclass");
        self.writeln("from typing import List, Optional, Any, Dict");
        self.writeln("from enum import Enum");
        self.writeln("import sys");
        self.writeln("");

        // Generate Items
        for item in &program.items {
            match item {
                Item::Struct(s) => self.generate_struct(s),
                Item::Enum(e) => self.generate_enum(e),
                Item::Function(f) => self.generate_function(f),
                Item::Use(u) => self.generate_use(u),
                _ => self.writeln(&format!("# Unimplemented item: {:?}", item)),
            }
        }

        // App Init or Main execution
        let app_init =
            FrameworkSelector::generate_python_app_init(self.framework, self.routes.clone());
        if !app_init.is_empty() {
            self.writeln("");
            self.writeln(&app_init);
        } else {
            // Default main check
            self.writeln("");
            self.writeln("if __name__ == \"__main__\":");
            self.indent();
            self.writeln("try:");
            self.indent();
            self.writeln("if \"main\" in globals():");
            self.indent();
            self.writeln("main()");
            self.dedent();
            self.dedent();
            self.writeln("except Exception as e:");
            self.indent();
            self.writeln("print(f\"Error: {e}\", file=sys.stderr)");
            self.writeln("sys.exit(1)");
            self.dedent();
            self.dedent();
        }

        Ok(self.output.clone())
    }

    fn get_target_language(&self) -> TargetLanguage {
        TargetLanguage::Python
    }
}

impl PythonCodeGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            framework: Framework::Axum,
            routes: Vec::new(),
        }
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }

    fn writeln(&mut self, s: &str) {
        let indent = "    ".repeat(self.indent_level);
        self.output.push_str(&format!("{}{}\n", indent, s));
    }

    fn write(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn generate_use(&mut self, u: &Use) {
        let path = u.path.join(".");
        self.writeln(&format!("import {}", path));
    }

    fn generate_struct(&mut self, s: &Struct) {
        if matches!(self.framework, Framework::FastAPI) {
            self.writeln(&format!("class {}(BaseModel):", s.name));
        } else {
            self.writeln("@dataclass");
            self.writeln(&format!("class {}:", s.name));
        }

        self.indent();

        if s.fields.is_empty() {
            self.writeln("pass");
        } else {
            for field in &s.fields {
                let py_type = self.map_type(&field.field_type);
                self.writeln(&format!("{}: {}", field.name, py_type));
            }
        }

        self.dedent();
        self.writeln("");
    }

    fn generate_enum(&mut self, e: &Enum) {
        self.writeln(&format!("class {}(Enum):", e.name));
        self.indent();
        if e.variants.is_empty() {
            self.writeln("pass");
        } else {
            for (idx, variant) in e.variants.iter().enumerate() {
                if variant.data.is_none() {
                    self.writeln(&format!("{} = {}", variant.name, idx));
                } else {
                    self.writeln(&format!("# Complex variant {} skipped", variant.name));
                }
            }
        }
        self.dedent();
        self.writeln("");
    }

    fn add_route(&mut self, method: &str, decorator: &Decorator, function_name: &str) {
        if let Some(arg) = decorator.args.first() {
            if let DecoratorArg::String(path) = arg {
                self.routes
                    .push((method.to_string(), path.clone(), function_name.to_string()));
            }
        }
    }

    fn generate_function(&mut self, f: &Function) {
        // Collect routes
        for decorator in &f.decorators {
            match decorator.name.as_str() {
                "Get" | "@Get" => self.add_route("GET", decorator, &f.name),
                "Post" | "@Post" => self.add_route("POST", decorator, &f.name),
                "Put" | "@Put" => self.add_route("PUT", decorator, &f.name),
                "Delete" | "@Delete" => self.add_route("DELETE", decorator, &f.name),
                _ => {}
            }
        }

        let return_type = f
            .return_type
            .as_ref()
            .map(|t| format!(" -> {}", self.map_type(t)))
            .unwrap_or_else(|| " -> None".to_string());

        let params: Vec<String> = f
            .params
            .iter()
            .map(|p| format!("{}: {}", p.name, self.map_type(&p.param_type)))
            .collect();

        self.writeln(&format!(
            "def {}({}){}:",
            f.name,
            params.join(", "),
            return_type
        ));
        self.indent();

        if f.body.statements.is_empty() {
            self.writeln("pass");
        } else {
            for stmt in &f.body.statements {
                self.generate_statement(stmt);
            }
        }

        self.dedent();
        self.writeln("");
    }

    fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Return(ret_stmt) => {
                self.write(&format!(
                    "{}{}",
                    "    ".repeat(self.indent_level),
                    "return "
                ));
                if let Some(e) = &ret_stmt.value {
                    self.generate_expression(e);
                }
                self.write("\n");
            }
            Statement::Expression(expr_stmt) => {
                self.write(&format!("{}", "    ".repeat(self.indent_level)));
                self.generate_expression(&expr_stmt.expression);
                self.write("\n");
            }
            Statement::Let(let_stmt) => {
                self.write(&format!(
                    "{}{} = ",
                    "    ".repeat(self.indent_level),
                    let_stmt.name
                ));
                self.generate_expression(&let_stmt.value);
                self.write("\n");
            }
            Statement::If(if_stmt) => {
                self.write(&format!("{}if ", "    ".repeat(self.indent_level)));
                self.generate_expression(&if_stmt.condition);
                self.write(":\n");
                self.indent();
                for s in &if_stmt.then_block.statements {
                    self.generate_statement(s);
                }
                if if_stmt.then_block.statements.is_empty() {
                    self.writeln("pass");
                }
                self.dedent();

                if let Some(else_block) = &if_stmt.else_block {
                    self.writeln("else:");
                    self.indent();
                    for s in &else_block.statements {
                        self.generate_statement(s);
                    }
                    if else_block.statements.is_empty() {
                        self.writeln("pass");
                    }
                    self.dedent();
                }
            }
            Statement::For(for_stmt) => {
                self.write("for ");
                self.generate_expression(&for_stmt.iterable);
                self.writeln(&format!(" as {}:", for_stmt.variable));
                self.indent();
                for s in &for_stmt.body.statements {
                    self.generate_statement(s);
                }
                self.dedent();
            }
            Statement::While(while_stmt) => {
                self.write("while ");
                self.generate_expression(&while_stmt.condition);
                self.writeln(":");
                self.indent();
                for s in &while_stmt.body.statements {
                    self.generate_statement(s);
                }
                self.dedent();
            }
            Statement::Match(match_stmt) => {
                self.write("match ");
                self.generate_expression(&match_stmt.expression);
                self.writeln(":");
                self.indent();
                for arm in &match_stmt.arms {
                    self.write("case ");
                    match &arm.pattern {
                        crate::parser::ast::Pattern::Literal(lit) => self.generate_literal(lit),
                        crate::parser::ast::Pattern::Identifier(name) => self.write(name),
                        _ => self.write("_"),
                    }
                    if let Some(guard) = &arm.guard {
                        self.write(" if ");
                        self.generate_expression(guard);
                    }
                    self.writeln(":");
                    self.indent();
                    for s in &arm.body.statements {
                        self.generate_statement(s);
                    }
                    self.dedent();
                }
                self.dedent();
            }
            Statement::Throw(throw_stmt) => {
                self.write("raise ");
                self.generate_expression(&throw_stmt.expression);
                self.writeln("");
            }
            Statement::Break(_) => {
                self.writeln("break");
            }
            Statement::Try(_) => {
                panic!("Try statement found after desugaring pass");
            }
        }
    }

    fn generate_expression(&mut self, expr: &Expression) {
        match expr {
            Expression::Literal(lit) => self.generate_literal(lit),
            Expression::Identifier(name) => self.write(name),
            Expression::BinaryOp { left, op, right } => {
                self.generate_expression(left);
                self.write(&format!(" {} ", self.map_op(op)));
                self.generate_expression(right);
            }
            Expression::Call { callee, args } => {
                if let Expression::Identifier(name) = &**callee {
                    if name == "println" {
                        self.write("print(");
                        for (i, arg) in args.iter().enumerate() {
                            if i > 0 {
                                self.write(", ");
                            }
                            self.generate_expression(arg);
                        }
                        self.write(")");
                        return;
                    }
                } else if let Expression::Member { object, member } = &**callee {
                    // Handle stdlib calls like math.max, json.stringify
                    if let Expression::Identifier(mod_name) = &**object {
                        if self.try_generate_stdlib_call(mod_name, member, args) {
                            return;
                        }
                    }

                    // Default member call
                    self.generate_expression(callee);
                    self.write("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.generate_expression(arg);
                    }
                    self.write(")");
                    return;
                }

                self.generate_expression(callee);
                self.write("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.generate_expression(arg);
                }
                self.write(")");
            }
            Expression::StructLiteral { name, fields } => {
                self.write(&format!("{}(", name));
                let args: Vec<String> = fields
                    .iter()
                    .map(|(k, v)| {
                        let mut temp_gen = PythonCodeGenerator::new();
                        temp_gen.generate_expression(v);
                        format!("{}={}", k, temp_gen.output)
                    })
                    .collect();
                self.write(&args.join(", "));
                self.write(")");
            }
            Expression::ListLiteral(items) => {
                self.write("[");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.generate_expression(item);
                }
                self.write("]");
            }
            Expression::MapLiteral(items) => {
                self.write("{");
                for (i, (k, v)) in items.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.write(&format!("\"{}\": ", k));
                    self.generate_expression(v);
                }
                self.write("}");
            }
            Expression::Member { object, member } => {
                self.generate_expression(object);
                self.write(&format!(".{}", member));
            }
            Expression::Index { object, index } => {
                self.generate_expression(object);
                self.write("[");
                self.generate_expression(index);
                self.write("]");
            }
            Expression::UnaryOp { op, expr } => {
                match op {
                    crate::parser::ast::UnaryOperator::Not => self.write("not "),
                    crate::parser::ast::UnaryOperator::Minus => self.write("-"),
                }
                self.generate_expression(expr);
            }
            Expression::Assignment { target, value } => {
                self.generate_expression(target);
                self.write(" = ");
                self.generate_expression(value);
            }
            Expression::If {
                condition,
                then_expr: _,
                else_expr,
            } => {
                self.write("(");
                self.generate_expression(condition);
                self.write(" if ");
                self.generate_expression(condition);
                self.write(" else ");
                self.generate_expression(else_expr);
            }
            Expression::Await { expr } => {
                self.write("await ");
                self.generate_expression(expr);
            }
            Expression::FormatString { parts } => {
                self.write("f\"");
                for part in parts {
                    match part {
                        crate::parser::ast::FormatStringPart::Text(s) => {
                            self.write(&s.replace("\"", "\\\""));
                        }
                        crate::parser::ast::FormatStringPart::Expression(e) => {
                            self.write("{");
                            self.generate_expression(e);
                            self.write("}");
                        }
                    }
                }
                self.write("\"");
            }
            Expression::Lambda { params, body, .. } => {
                self.write("lambda ");
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.write(&param.name);
                }
                self.write(": ");
                match body.as_ref() {
                    Expression::Block(block) => {
                        if let Some(stmt) = block.statements.last() {
                            if let Statement::Return(ret) = stmt {
                                if let Some(expr) = &ret.value {
                                    self.generate_expression(expr);
                                }
                            }
                        }
                    }
                    _ => self.generate_expression(body),
                }
            }
            Expression::LLMCall { method, args } => {
                self.write(&format!("llm_{}(", method));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.generate_expression(arg);
                }
                self.write(")");
            }
            Expression::GenericConstructor { name, args, .. } => {
                self.write(&format!("{}(", name));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.generate_expression(arg);
                }
                self.write(")");
            }
            Expression::Block(block) => {
                for s in &block.statements {
                    self.generate_statement(s);
                }
            }
        }
    }

    fn generate_literal(&mut self, lit: &Literal) {
        match lit {
            Literal::String(s) => self.write(&format!("\"{}\"", s)),
            Literal::Number(n) => self.write(&n.to_string()),
            Literal::Boolean(b) => self.write(if *b { "True" } else { "False" }),
            Literal::Null => self.write("None"),
        }
    }

    fn map_op(&self, op: &BinaryOperator) -> String {
        match op {
            BinaryOperator::Add => "+".to_string(),
            BinaryOperator::Subtract => "-".to_string(),
            BinaryOperator::Multiply => "*".to_string(),
            BinaryOperator::Divide => "/".to_string(),
            BinaryOperator::Modulo => "%".to_string(),
            BinaryOperator::Eq => "==".to_string(),
            BinaryOperator::NotEq => "!=".to_string(),
            BinaryOperator::Lt => "<".to_string(),
            BinaryOperator::Gt => ">".to_string(),
            BinaryOperator::LtEq => "<=".to_string(),
            BinaryOperator::GtEq => ">=".to_string(),
            BinaryOperator::And => "and".to_string(),
            BinaryOperator::Or => "or".to_string(),
            BinaryOperator::In => "in".to_string(),
        }
    }

    fn map_type(&self, ty: &Type) -> String {
        match ty {
            Type::String => "str".to_string(),
            Type::Number => "float".to_string(), // Or int/float Union
            Type::Boolean => "bool".to_string(),
            Type::Void => "None".to_string(),
            Type::List(inner) => format!("List[{}]", self.map_type(inner)),
            Type::Map { key, value } => {
                format!("Dict[{}, {}]", self.map_type(key), self.map_type(value))
            }
            Type::Named(name) => match name.as_str() {
                "int" | "float" | "str" | "bool" | "list" | "dict" | "Any" => name.clone(),
                _ => format!("'{}'", name),
            },
            Type::Any => "Any".to_string(),
            Type::Optional(inner) => format!("Optional[{}]", self.map_type(inner)),
            _ => "Any".to_string(),
        }
    }

    fn try_generate_stdlib_call(
        &mut self,
        module: &str,
        function: &str,
        args: &[Expression],
    ) -> bool {
        match module {
            "math" => match function {
                "min" | "max" | "abs" | "floor" | "ceil" | "round" | "sqrt" => {
                    self.write(&format!("math.{}(", function));
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.generate_expression(arg);
                    }
                    self.write(")");
                    true
                }
                _ => false,
            },
            "json" => match function {
                "stringify" => {
                    self.write("json.dumps(");
                    if let Some(arg) = args.first() {
                        self.generate_expression(arg);
                    }
                    self.write(")");
                    true
                }
                "parse" => {
                    self.write("json.loads(");
                    if let Some(arg) = args.first() {
                        self.generate_expression(arg);
                    }
                    self.write(")");
                    true
                }
                _ => false,
            },
            "utils" => match function {
                "sleep" => {
                    self.write("time.sleep(");
                    if let Some(arg) = args.first() {
                        // Velin uses ms, Python sleep uses seconds
                        self.generate_expression(arg);
                        self.write(" / 1000");
                    }
                    self.write(")");
                    true
                }
                _ => false,
            },
            _ => false,
        }
    }
}
