use crate::parser::ast::*;
use crate::codegen::traits::{CodeGenerator, CodegenConfig, TargetLanguage};
use crate::codegen::framework::{Framework, FrameworkSelector};
use crate::compiler::language::VELISCH_FINGERPRINT;

pub struct PhpCodeGenerator {
    output: String,
    indent_level: usize,
    framework: Framework,
    routes: Vec<(String, String, String)>, // Method, Path, FunctionName
}

impl CodeGenerator for PhpCodeGenerator {
    fn generate(&mut self, program: &Program, config: &CodegenConfig) -> anyhow::Result<String> {
        self.output.clear();
        self.indent_level = 0;
        self.routes.clear();

        // Detect framework
        let framework = FrameworkSelector::detect_framework(program, config.framework.as_deref());
        self.framework = framework;

        self.writeln("<?php");
        self.writeln(&format!("// {}", VELISCH_FINGERPRINT));
        self.writeln("// Generated by VelinScript Compiler");
        self.writeln("declare(strict_types=1);");
        self.writeln("");
        
        // Framework imports
        self.writeln(&FrameworkSelector::generate_imports(framework));

        // Separate items
        let mut structs = Vec::new();
        let mut enums = Vec::new();
        let mut functions = Vec::new();
        let mut uses = Vec::new();

        for item in &program.items {
            match item {
                Item::Struct(s) => structs.push(s),
                Item::Enum(e) => enums.push(e),
                Item::Function(f) => functions.push(f),
                Item::Use(u) => uses.push(u),
                _ => {}
            }
        }

        // Generate Uses, Enums, Structs first (Global scope)
        for u in uses { self.generate_use(u); }
        for e in enums { self.generate_enum(e); }
        for s in structs { self.generate_struct(s); }

        // Generate Functions (Wrapped in Controller for Laravel/Symfony, or Global)
        let is_framework = matches!(self.framework, Framework::Laravel | Framework::Symfony);
        
        if is_framework {
            // Class Wrapper
            let controller_name = "AppController"; // Default name
            self.writeln(&format!("class {} extends Controller {{", controller_name));
            self.indent();
            
            for f in functions {
                self.generate_function(f, true);
            }
            
            self.dedent();
            self.writeln("}");
            self.writeln("");

            // Generate Routes (outside class)
            let routes_code = FrameworkSelector::generate_php_routes(self.framework, self.routes.clone(), controller_name);
            if !routes_code.is_empty() {
                self.writeln("");
                self.write(&routes_code);
            }

        } else {
            // Global Functions
            for f in functions {
                self.generate_function(f, false);
            }

            // Main execution check
            self.writeln("");
            self.writeln("if (basename(__FILE__) == basename($_SERVER['SCRIPT_FILENAME'])) {");
            self.indent();
            self.writeln("if (function_exists('main')) {");
            self.indent();
            self.writeln("main();");
            self.dedent();
            self.writeln("}");
            self.dedent();
            self.writeln("}");
        }

        Ok(self.output.clone())
    }

    fn get_target_language(&self) -> TargetLanguage {
        TargetLanguage::Php
    }
}

impl PhpCodeGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            framework: Framework::Axum,
            routes: Vec::new(),
        }
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }

    fn writeln(&mut self, s: &str) {
        let indent = "    ".repeat(self.indent_level);
        self.output.push_str(&format!("{}{}\n", indent, s));
    }

    fn write(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn generate_use(&mut self, u: &Use) {
        // Simple mapping: use foo::bar -> require_once 'foo/bar.php';
        // This is a naive implementation
        let path = u.path.join("/");
        self.writeln(&format!("require_once __DIR__ . '/{}.php';", path));
    }

    fn generate_struct(&mut self, s: &Struct) {
        self.writeln(&format!("class {} {{", s.name));
        self.indent();

        // Fields
        for field in &s.fields {
            let php_type = self.map_type(&field.field_type);
            self.writeln(&format!("public {} ${};", php_type, field.name));
        }

        self.writeln("");
        
        // Constructor
        if !s.fields.is_empty() {
            let params: Vec<String> = s.fields.iter()
                .map(|f| format!("{} ${}", self.map_type(&f.field_type), f.name))
                .collect();
            self.writeln(&format!("public function __construct({}) {{", params.join(", ")));
            self.indent();
            for field in &s.fields {
                self.writeln(&format!("$this->{} = ${};", field.name, field.name));
            }
            self.dedent();
            self.writeln("}");
        }

        self.dedent();
        self.writeln("}");
        self.writeln("");
    }

    fn generate_enum(&mut self, e: &Enum) {
        self.writeln(&format!("enum {} {{", e.name));
        self.indent();
        for variant in &e.variants {
            if variant.data.is_none() {
                self.writeln(&format!("case {};", variant.name));
            } else {
                self.writeln(&format!("// Complex variant {} skipped (PHP Enums are limited)", variant.name));
            }
        }
        self.dedent();
        self.writeln("}");
        self.writeln("");
    }

    fn generate_function(&mut self, f: &Function, is_method: bool) {
        // Check for route decorators
        let mut route_info = None;
        for decorator in &f.decorators {
             match decorator.name.as_str() {
                 "Get" | "@Get" => route_info = Some(("get", decorator)),
                 "Post" | "@Post" => route_info = Some(("post", decorator)),
                 "Put" | "@Put" => route_info = Some(("put", decorator)),
                 "Delete" | "@Delete" => route_info = Some(("delete", decorator)),
                 _ => {}
             }
        }

        if let Some((method, decorator)) = route_info {
             let path = if let Some(DecoratorArg::String(p)) = decorator.args.first() {
                 p.clone()
             } else {
                 "/".to_string()
             };

             if matches!(self.framework, Framework::Laravel) {
                // If we are generating a controller class method, we just record the route
                if is_method {
                    self.routes.push((method.to_string(), path, f.name.clone()));
                } else {
                    // Fallback for non-class generation
                    let params: Vec<String> = f.params.iter()
                        .map(|p| format!("{} ${}", self.map_type(&p.param_type), p.name))
                        .collect();
                    
                    self.writeln(&format!("Route::{}(\"{}\", function({}) {{", method, path, params.join(", ")));
                    self.indent();
                    for stmt in &f.body.statements {
                        self.generate_statement(stmt);
                    }
                    self.dedent();
                    self.writeln("});");
                    self.writeln("");
                    return;
                }
            } else if matches!(self.framework, Framework::Symfony) {
                // Generate attribute
                if let Some(attr) = FrameworkSelector::generate_method_attributes(self.framework, method, &path) {
                    self.writeln(&attr);
                }
            }
        }

        let visibility = if is_method { "public " } else { "" };
        let return_type = f.return_type.as_ref().map(|t| format!(": {}", self.map_type(t))).unwrap_or_else(|| ": void".to_string());
        
        let params: Vec<String> = f.params.iter()
            .map(|p| format!("{} ${}", self.map_type(&p.param_type), p.name))
            .collect();

        self.writeln(&format!("{}function {}({}){} {{", visibility, f.name, params.join(", "), return_type));
        self.indent();
        
        // Body
        for stmt in &f.body.statements {
            self.generate_statement(stmt);
        }

        self.dedent();
        self.writeln("}");
        self.writeln("");
    }

    fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Return(ret_stmt) => {
                self.write(&format!("{}{}", "    ".repeat(self.indent_level), "return "));
                if let Some(e) = &ret_stmt.value {
                    self.generate_expression(e);
                }
                self.write(";\n");
            },
            Statement::Expression(expr_stmt) => {
                self.write(&format!("{}", "    ".repeat(self.indent_level)));
                // ExpressionStatement might wrap an expression. Wait, ExpressionStatement is an enum or struct?
                // Checking AST: pub struct ExpressionStatement(pub Expression); or similar? 
                // Ah, Statement::Expression(ExpressionStatement). Let's check definition of ExpressionStatement.
                // It was not visible in previous `read` output fully, but usually it wraps an Expression.
                // Assuming `pub struct ExpressionStatement { pub expression: Expression }` or tuple struct.
                // Actually in Velin parser, it's likely just `Expression`. 
                // Wait, AST says `Expression(ExpressionStatement)`. 
                // Let's assume ExpressionStatement is just an alias or struct wrapping Expression.
                // If I can't check, I'll assume it has a field `expression` or it is the expression.
                // Let's check AST again quickly for `ExpressionStatement`.
                // It wasn't shown. But typically it is `pub struct ExpressionStatement { pub expression: Expression }`.
                // I'll assume `expr_stmt.expression`.
                self.generate_expression(&expr_stmt.expression);
                self.write(";\n");
            },
            Statement::Let(let_stmt) => {
                self.write(&format!("{}${} = ", "    ".repeat(self.indent_level), let_stmt.name));
                self.generate_expression(&let_stmt.value);
                self.write(";\n");
            },
            Statement::If(if_stmt) => {
                self.write(&format!("{}if (", "    ".repeat(self.indent_level)));
                self.generate_expression(&if_stmt.condition);
                self.write(") {\n");
                self.indent();
                for s in &if_stmt.then_block.statements {
                    self.generate_statement(s);
                }
                self.dedent();
                
                if let Some(else_block) = &if_stmt.else_block {
                    self.writeln("} else {");
                    self.indent();
                    for s in &else_block.statements {
                        self.generate_statement(s);
                    }
                    self.dedent();
                }
                self.writeln("}");
            },
            Statement::For(for_stmt) => {
                self.write(&format!("{}foreach (", "    ".repeat(self.indent_level)));
                self.generate_expression(&for_stmt.iterable);
                self.writeln(&format!(" as ${}) {{", for_stmt.variable));
                self.indent();
                for s in &for_stmt.body.statements {
                    self.generate_statement(s);
                }
                self.dedent();
                self.writeln("}");
            },
            Statement::While(while_stmt) => {
                self.write(&format!("{}while (", "    ".repeat(self.indent_level)));
                self.generate_expression(&while_stmt.condition);
                self.writeln(") {");
                self.indent();
                for s in &while_stmt.body.statements {
                    self.generate_statement(s);
                }
                self.dedent();
                self.writeln("}");
            },
            Statement::Match(match_stmt) => {
                self.write(&format!("{}match (", "    ".repeat(self.indent_level)));
                self.generate_expression(&match_stmt.expression);
                self.writeln(") {");
                self.indent();
                for arm in &match_stmt.arms {
                    self.write(&format!("{}", "    ".repeat(self.indent_level)));
                    // Pattern matching in PHP ist eingeschränkt, nutze switch-ähnliche Syntax
                    match &arm.pattern {
                        crate::parser::ast::Pattern::Literal(lit) => {
                            self.generate_literal(lit);
                        },
                        crate::parser::ast::Pattern::Identifier(name) => {
                            self.write(name);
                        },
                        _ => self.write("_"),
                    }
                    self.write(" => ");
                    if let Some(guard) = &arm.guard {
                        self.write("if (");
                        self.generate_expression(guard);
                        self.write(") ");
                    }
                    self.writeln("{");
                    self.indent();
                    for s in &arm.body.statements {
                        self.generate_statement(s);
                    }
                    self.dedent();
                    self.writeln("},");
                }
                self.dedent();
                self.writeln("}");
            },
            Statement::Throw(throw_stmt) => {
                self.write(&format!("{}throw ", "    ".repeat(self.indent_level)));
                self.generate_expression(&throw_stmt.expression);
                self.writeln(";");
            },
            Statement::Break(_) => {
                self.writeln(&format!("{}break;", "    ".repeat(self.indent_level)));
            },
            Statement::Try(_) => {
                panic!("Try statement found after desugaring pass");
            },
        }
    }

    fn generate_expression(&mut self, expr: &Expression) {
        match expr {
            Expression::Literal(lit) => self.generate_literal(lit),
            Expression::Identifier(name) => self.write(&format!("${}", name)),
            Expression::BinaryOp { left, op, right } => {
                let is_string_concat = if *op == BinaryOperator::Add {
                     self.is_string_expr(left) || self.is_string_expr(right)
                } else {
                    false
                };

                self.generate_expression(left);
                if is_string_concat {
                     self.write(" . ");
                } else {
                    self.write(&format!(" {} ", self.map_op(op)));
                }
                self.generate_expression(right);
            },
            Expression::Call { callee, args } => {
                // Check if callee is identifier
                if let Expression::Identifier(name) = &**callee {
                    if name == "println" {
                         self.write("echo ");
                        for (i, arg) in args.iter().enumerate() {
                            if i > 0 { self.write(" . "); }
                            self.generate_expression(arg);
                        }
                        self.write(" . PHP_EOL");
                        return;
                    }
                    // Standard function call: no $ prefix
                    self.write(name);
                } else if let Expression::Member { object, member } = &**callee {
                    // Handle stdlib calls like math.max, json.stringify
                    if let Expression::Identifier(mod_name) = &**object {
                        if self.try_generate_stdlib_call(mod_name, member, args) {
                            return;
                        }
                    }
                    
                    // Default member call
                    self.generate_expression(callee);
                } else {
                    self.generate_expression(callee);
                }
                
                self.write("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.generate_expression(arg);
                }
                self.write(")");
            },
            Expression::StructLiteral { name, fields } => {
                self.write(&format!("new {}(", name));
                let args: Vec<String> = fields.iter()
                    .map(|(k, v)| {
                        let mut temp_gen = PhpCodeGenerator::new();
                        temp_gen.generate_expression(v);
                        format!("{}: {}", k, temp_gen.output)
                    })
                    .collect();
                 self.write(&args.join(", "));
                 self.write(")");
            },
            Expression::ListLiteral(items) => {
                 self.write("[");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.generate_expression(item);
                }
                self.write("]");
            },
            Expression::MapLiteral(items) => {
                 self.write("[");
                for (i, (k, v)) in items.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.write(&format!("\"{}\" => ", k));
                    self.generate_expression(v);
                }
                self.write("]");
            },
            Expression::Member { object, member } => {
                self.generate_expression(object);
                self.write(&format!("->{}", member));
            },
            Expression::Index { object, index } => {
                self.generate_expression(object);
                self.write("[");
                self.generate_expression(index);
                self.write("]");
            },
            Expression::Assignment { target, value } => {
                self.generate_expression(target);
                self.write(" = ");
                self.generate_expression(value);
            },
            Expression::If { condition, then_expr, else_expr } => {
                self.write("(");
                self.generate_expression(condition);
                self.write(" ? ");
                self.generate_expression(then_expr);
                self.write(" : ");
                self.generate_expression(else_expr);
                self.write(")");
            },
            Expression::Await { expr } => {
                self.write("await ");
                self.generate_expression(expr);
            },
            Expression::UnaryOp { op, expr } => {
                match op {
                    crate::parser::ast::UnaryOperator::Not => self.write("!"),
                    crate::parser::ast::UnaryOperator::Minus => self.write("-"),
                }
                self.generate_expression(expr);
            },
            Expression::FormatString { parts } => {
                self.write("\"");
                for part in parts {
                    match part {
                        crate::parser::ast::FormatStringPart::Text(s) => {
                            self.write(&s.replace("\"", "\\\""));
                        },
                        crate::parser::ast::FormatStringPart::Expression(e) => {
                            self.write("{");
                            self.generate_expression(e);
                            self.write("}");
                        },
                    }
                }
                self.write("\"");
            },
            Expression::Lambda { params, body, .. } => {
                self.write("function(");
                for (i, param) in params.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.write(&format!("${}", param.name));
                }
                self.write(") { return ");
                match body.as_ref() {
                    Expression::Block(block) => {
                        for s in &block.statements {
                            self.generate_statement(s);
                        }
                    },
                    _ => self.generate_expression(body),
                }
                self.write("; }");
            },
            Expression::LLMCall { method, args } => {
                self.write(&format!("llm_{}(", method));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.generate_expression(arg);
                }
                self.write(")");
            },
            Expression::GenericConstructor { name, args, .. } => {
                self.write(&format!("new {}(", name));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.write(", "); }
                    self.generate_expression(arg);
                }
                self.write(")");
            },
            Expression::Block(block) => {
                self.writeln("{");
                self.indent();
                for s in &block.statements {
                    self.generate_statement(s);
                }
                self.dedent();
                self.write(&format!("{}", "    ".repeat(self.indent_level)));
                self.write("}");
            },
        }
    }

    fn is_string_expr(&self, expr: &Expression) -> bool {
        match expr {
            Expression::Literal(Literal::String(_)) => true,
            Expression::BinaryOp { left, op, right } => {
                if *op == BinaryOperator::Add {
                    self.is_string_expr(left) || self.is_string_expr(right)
                } else {
                    false
                }
            },
            _ => false,
        }
    }

    fn generate_literal(&mut self, lit: &Literal) {
        match lit {
            Literal::String(s) => self.write(&format!("\"{}\"", s)),
            Literal::Number(n) => self.write(&n.to_string()),
            Literal::Boolean(b) => self.write(if *b { "true" } else { "false" }),
            Literal::Null => self.write("null"),
        }
    }

    fn map_op(&self, op: &BinaryOperator) -> String {
        match op {
            BinaryOperator::Add => "+".to_string(),
            BinaryOperator::Subtract => "-".to_string(),
            BinaryOperator::Multiply => "*".to_string(),
            BinaryOperator::Divide => "/".to_string(),
            BinaryOperator::Modulo => "%".to_string(),
            BinaryOperator::Eq => "===".to_string(),
            BinaryOperator::NotEq => "!==".to_string(),
            BinaryOperator::Lt => "<".to_string(),
            BinaryOperator::Gt => ">".to_string(),
            BinaryOperator::LtEq => "<=".to_string(),
            BinaryOperator::GtEq => ">=".to_string(),
            BinaryOperator::And => "&&".to_string(),
            BinaryOperator::Or => "||".to_string(),
        }
    }

    fn map_type(&self, ty: &Type) -> String {
        match ty {
            Type::String => "string".to_string(),
            Type::Number => "float".to_string(), // Or mixed int/float
            Type::Boolean => "bool".to_string(),
            Type::Void => "void".to_string(),
            Type::List(_) => "array".to_string(),
            Type::Map { .. } => "array".to_string(),
            Type::Named(name) => name.clone(),
            Type::Any => "mixed".to_string(),
            Type::Optional(inner) => format!("?{}", self.map_type(inner)),
            _ => "mixed".to_string(),
        }
    }

    fn try_generate_stdlib_call(&mut self, module: &str, function: &str, args: &[Expression]) -> bool {
        match module {
            "math" => match function {
                "min" | "max" | "abs" | "floor" | "ceil" | "round" => {
                    self.write(function);
                    self.write("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 { self.write(", "); }
                        self.generate_expression(arg);
                    }
                    self.write(")");
                    true
                },
                "sqrt" => {
                    self.write("sqrt(");
                    if let Some(arg) = args.first() { self.generate_expression(arg); }
                    self.write(")");
                    true
                },
                _ => false,
            },
            "json" => match function {
                "stringify" => {
                    self.write("json_encode(");
                    if let Some(arg) = args.first() { self.generate_expression(arg); }
                    self.write(")");
                    true
                },
                "parse" => {
                    self.write("json_decode(");
                    if let Some(arg) = args.first() { self.generate_expression(arg); }
                    self.write(", true)"); // Associative array
                    true
                },
                _ => false,
            },
            "utils" => match function {
                "sleep" => {
                    self.write("usleep(");
                    if let Some(arg) = args.first() { 
                        // Velin uses ms, PHP usleep uses microseconds
                        self.generate_expression(arg);
                        self.write(" * 1000");
                    }
                    self.write(")");
                    true
                },
                _ => false,
            },
            _ => false,
        }
    }
}
