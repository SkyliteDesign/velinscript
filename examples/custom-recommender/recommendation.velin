// Custom Recommender - Recommendation Algorithmus
// Hybrid Recommendation System: Kombiniert Embedding-basierte und Collaborative Filtering Ansätze

// Konfiguration wird aus config.velin geladen
// use config::*;

// calculateSimilarity - Berechnet Ähnlichkeit zwischen zwei Embeddings (Cosine Similarity)
// Input: Zwei Embedding-Vektoren
// Output: Ähnlichkeits-Score zwischen 0.0 und 1.0
fn calculateSimilarity(embedding1: List<number>, embedding2: List<number>): number {
    if (embedding1.length != embedding2.length || embedding1.length == 0) {
        return 0.0;
    }
    
    // Dot Product berechnen
    let mut dotProduct = 0.0;
    for (i in 0..embedding1.length) {
        dotProduct = dotProduct + (embedding1[i] * embedding2[i]);
    }
    
    // Magnitude (Länge) der Vektoren berechnen
    let mut magnitude1 = 0.0;
    let mut magnitude2 = 0.0;
    for (i in 0..embedding1.length) {
        magnitude1 = magnitude1 + (embedding1[i] * embedding1[i]);
        magnitude2 = magnitude2 + (embedding2[i] * embedding2[i]);
    }
    magnitude1 = Math.sqrt(magnitude1);
    magnitude2 = Math.sqrt(magnitude2);
    
    // Cosine Similarity = Dot Product / (Magnitude1 * Magnitude2)
    if (magnitude1 == 0.0 || magnitude2 == 0.0) {
        return 0.0;
    }
    
    return dotProduct / (magnitude1 * magnitude2);
}

// collaborativeFilter - Collaborative Filtering Algorithmus
// Findet ähnliche Nutzer basierend auf gemeinsamen Präferenzen
// Input: userId, alle Items, alle UserPreferences
// Output: Liste von empfohlenen Items mit Scores
fn collaborativeFilter(
    userId: string,
    allItems: List<Item>,
    allPreferences: List<UserPreference>
): List<Recommendation> {
    // 1. Finde alle Präferenzen des aktuellen Nutzers
    let userPreferences = allPreferences.filter(|p| p.userId == userId);
    
    if (userPreferences.length == 0) {
        return [];
    }
    
    // 2. Finde ähnliche Nutzer (die ähnliche Items bewertet haben)
    let mut similarUsers = Map<string, number>();
    
    for (pref in allPreferences) {
        if (pref.userId != userId) {
            // Prüfe ob dieser Nutzer Items bewertet hat, die der aktuelle Nutzer auch bewertet hat
            let userRatedSameItem = userPreferences.find(|up| up.itemId == pref.itemId);
            if (userRatedSameItem != null) {
                // Berechne Ähnlichkeit basierend auf Bewertungsunterschied
                let ratingDiff = Math.abs(userRatedSameItem.rating - pref.rating);
                let similarity = 1.0 - (ratingDiff / 5.0); // Normalisiere auf 0-1
                
                if (!similarUsers.contains(pref.userId)) {
                    similarUsers[pref.userId] = 0.0;
                }
                similarUsers[pref.userId] = similarUsers[pref.userId] + similarity;
            }
        }
    }
    
    // 3. Finde Items die ähnliche Nutzer hoch bewertet haben, aber der aktuelle Nutzer noch nicht
    let mut itemScores = Map<string, number>();
    let userRatedItemIds = userPreferences.map(|p| p.itemId);
    
    for (pref in allPreferences) {
        if (similarUsers.contains(pref.userId) && !userRatedItemIds.contains(pref.itemId)) {
            let userSimilarity = similarUsers[pref.userId];
            let ratingScore = pref.rating / 5.0; // Normalisiere auf 0-1
            
            if (!itemScores.contains(pref.itemId)) {
                itemScores[pref.itemId] = 0.0;
            }
            itemScores[pref.itemId] = itemScores[pref.itemId] + (userSimilarity * ratingScore);
        }
    }
    
    // 4. Erstelle Recommendation-Objekte
    let mut recommendations = List<Recommendation>();
    for (itemId in itemScores.keys()) {
        let item = allItems.find(|i| i.id == itemId);
        if (item != null) {
            let score = itemScores[itemId] / similarUsers.length; // Normalisiere
            recommendations.push(Recommendation {
                itemId: itemId,
                score: score,
                reason: "Empfohlen basierend auf ähnlichen Nutzern",
                method: "collaborative",
                item: item,
            });
        }
    }
    
    // Sortiere nach Score (höchste zuerst)
    return recommendations.sort(|a, b| b.score - a.score);
}

// embeddingBasedRecommend - Embedding-basierte Empfehlungen
// Nutzt Vector-Ähnlichkeit um ähnliche Items zu finden
// Input: userId, userEmbedding, alle Items
// Output: Liste von empfohlenen Items basierend auf Embedding-Ähnlichkeit
fn embeddingBasedRecommend(
    userId: string,
    userEmbedding: List<number>,
    allItems: List<Item>
): List<Recommendation> {
    let mut recommendations = List<Recommendation>();
    
    for (item in allItems) {
        if (item.embedding.length > 0) {
            let similarity = calculateSimilarity(userEmbedding, item.embedding);
            
            recommendations.push(Recommendation {
                itemId: item.id,
                score: similarity,
                reason: "Ähnlich basierend auf Embedding-Vergleich",
                method: "embedding",
                item: item,
            });
        }
    }
    
    // Sortiere nach Score (höchste zuerst)
    return recommendations.sort(|a, b| b.score - a.score);
}

// hybridRecommend - Kombiniert Embedding-basierte und Collaborative Filtering Empfehlungen
// Dies ist der Hauptalgorithmus für das Recommendation System
// Input: userId, userEmbedding, alle Items, alle Preferences
// Output: Hybrid-Empfehlungen mit kombinierten Scores
fn hybridRecommend(
    userId: string,
    userEmbedding: List<number>,
    allItems: List<Item>,
    allPreferences: List<UserPreference>
): List<Recommendation> {
    // Lade Konfiguration
    let config = getConfig();
    let embeddingWeight = config.ml.recommendation.embeddingWeight;
    let collaborativeWeight = config.ml.recommendation.collaborativeWeight;
    let maxRecommendations = config.ml.recommendation.maxRecommendations;
    let minScore = config.ml.recommendation.minScore;
    
    // 1. Hole Embedding-basierte Empfehlungen
    let embeddingRecs = embeddingBasedRecommend(userId, userEmbedding, allItems);
    
    // 2. Hole Collaborative Filtering Empfehlungen
    let collaborativeRecs = collaborativeFilter(userId, allItems, allPreferences);
    
    // 3. Kombiniere beide Ansätze
    let mut combinedScores = Map<string, Recommendation>();
    
    // Füge Embedding-Empfehlungen hinzu
    for (rec in embeddingRecs) {
        let score = rec.score * embeddingWeight;
        combinedScores[rec.itemId] = Recommendation {
            itemId: rec.itemId,
            score: score,
            reason: rec.reason,
            method: "hybrid",
            item: rec.item,
        };
    }
    
    // Füge Collaborative Filtering Empfehlungen hinzu und kombiniere Scores
    for (rec in collaborativeRecs) {
        let score = rec.score * collaborativeWeight;
        if (combinedScores.contains(rec.itemId)) {
            // Kombiniere Scores wenn Item in beiden Listen ist
            let existing = combinedScores[rec.itemId];
            combinedScores[rec.itemId] = Recommendation {
                itemId: rec.itemId,
                score: existing.score + score,
                reason: "Kombiniert aus Embedding-Ähnlichkeit und ähnlichen Nutzern",
                method: "hybrid",
                item: rec.item,
            };
        } else {
            combinedScores[rec.itemId] = Recommendation {
                itemId: rec.itemId,
                score: score,
                reason: rec.reason,
                method: "hybrid",
                item: rec.item,
            };
        }
    }
    
    // 4. Konvertiere Map zu Liste und sortiere
    let mut finalRecommendations = List<Recommendation>();
    for (itemId in combinedScores.keys()) {
        let rec = combinedScores[itemId];
        // Filtere nach minScore
        if (rec.score >= minScore) {
            finalRecommendations.push(rec);
        }
    }
    
    // Sortiere nach Score
    finalRecommendations = finalRecommendations.sort(|a, b| b.score - a.score);
    
    // Begrenze auf maxRecommendations
    if (finalRecommendations.length > maxRecommendations) {
        finalRecommendations = finalRecommendations.take(maxRecommendations);
    }
    
    return finalRecommendations;
}

// getUserHistory - Ruft den Nutzerverlauf ab
// Input: userId, alle Preferences
// Output: Liste von UserPreferences sortiert nach Timestamp
fn getUserHistory(userId: string, allPreferences: List<UserPreference>): List<UserPreference> {
    let userPrefs = allPreferences.filter(|p| p.userId == userId);
    return userPrefs.sort(|a, b| b.timestamp.compare(a.timestamp));
}
