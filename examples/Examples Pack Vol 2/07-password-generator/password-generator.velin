// ================================================
// VelinScript Beispiel: Passwort-Generator
// ================================================
// Generiert sichere Passwörter mit verschiedenen
// Optionen und prüft Passwortstärke

// -------- Datenstrukturen --------

struct PasswordOptions {
    length: number,
    includeUppercase: boolean,
    includeLowercase: boolean,
    includeNumbers: boolean,
    includeSymbols: boolean,
    excludeSimilar: boolean, // z.B. O und 0, l und 1
    excludeAmbiguous: boolean, // z.B. {}[]()
}

struct GeneratedPassword {
    password: string,
    strength: string,
    score: number,
    entropy: number,
    suggestions: List<string>,
}

struct PasswordStrength {
    score: number, // 0-100
    level: string, // "Sehr schwach", "Schwach", "Mittel", "Stark", "Sehr stark"
    hasUppercase: boolean,
    hasLowercase: boolean,
    hasNumbers: boolean,
    hasSymbols: boolean,
    length: number,
    suggestions: List<string>,
}

// -------- Zeichensätze --------

fn getUppercase(): string {
    return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
}

fn getLowercase(): string {
    return "abcdefghijklmnopqrstuvwxyz";
}

fn getNumbers(): string {
    return "0123456789";
}

fn getSymbols(): string {
    return "!@#$%^&*()-_=+[]{}|;:,.<>?";
}

fn getSimilarChars(): string {
    return "il1Lo0O";
}

fn getAmbiguousChars(): string {
    return "{}[]()/\\'\"`~,;:.<>";
}

// -------- Hilfsfunktionen --------

// Berechnet Entropie eines Passworts
fn calculateEntropy(password: string, charsetSize: number): number {
    // Entropie = log2(mögliche Kombinationen)
    // = Länge * log2(Zeichensatzgröße)
    let length = password.length();
    return length * (log(charsetSize) / log(2));
}

// Bestimmt Zeichensatzgröße basierend auf Passwort
fn getCharsetSize(password: string): number {
    let size = 0;
    
    if (password.matches(".*[a-z].*")) {
        size = size + 26;
    }
    if (password.matches(".*[A-Z].*")) {
        size = size + 26;
    }
    if (password.matches(".*[0-9].*")) {
        size = size + 10;
    }
    if (password.matches(".*[^a-zA-Z0-9].*")) {
        size = size + 32; // Geschätzt für Symbole
    }
    
    return if (size == 0) { 1 } else { size };
}

// Prüft Passwortstärke
fn checkPasswordStrength(password: string): PasswordStrength {
    let length = password.length();
    let score = 0;
    let suggestions: List<string> = [];
    
    // Längen-Score
    if (length < 8) {
        score = score + 10;
        suggestions.push("Passwort sollte mindestens 8 Zeichen lang sein");
    } else if (length < 12) {
        score = score + 20;
        suggestions.push("Empfohlen: Mindestens 12 Zeichen");
    } else if (length < 16) {
        score = score + 30;
    } else {
        score = score + 40;
    }
    
    // Zeichentypen-Score
    let hasUpper = password.matches(".*[A-Z].*");
    let hasLower = password.matches(".*[a-z].*");
    let hasNumber = password.matches(".*[0-9].*");
    let hasSymbol = password.matches(".*[^a-zA-Z0-9].*");
    
    if (hasUpper) { score = score + 10; }
    else { suggestions.push("Füge Großbuchstaben hinzu"); }
    
    if (hasLower) { score = score + 10; }
    else { suggestions.push("Füge Kleinbuchstaben hinzu"); }
    
    if (hasNumber) { score = score + 15; }
    else { suggestions.push("Füge Zahlen hinzu"); }
    
    if (hasSymbol) { score = score + 25; }
    else { suggestions.push("Füge Sonderzeichen hinzu"); }
    
    // Prüfe auf häufige Muster
    if (password.toLowerCase().contains("password")) {
        score = score - 20;
        suggestions.push("Vermeide häufige Wörter wie 'password'");
    }
    
    if (password.contains("123") || password.contains("abc")) {
        score = score - 10;
        suggestions.push("Vermeide sequenzielle Zeichen");
    }
    
    // Bestimme Level
    let level: string;
    if (score < 30) {
        level = "Sehr schwach";
    } else if (score < 50) {
        level = "Schwach";
    } else if (score < 70) {
        level = "Mittel";
    } else if (score < 85) {
        level = "Stark";
    } else {
        level = "Sehr stark";
    }
    
    return PasswordStrength {
        score: score,
        level: level,
        hasUppercase: hasUpper,
        hasLowercase: hasLower,
        hasNumbers: hasNumber,
        hasSymbols: hasSymbol,
        length: length,
        suggestions: suggestions,
    };
}

// Generiert Zufallszeichen aus String
fn getRandomChar(chars: string): string {
    let index = randomInt(0, chars.length() - 1);
    return chars.substring(index, index + 1);
}

// Mischt String
fn shuffleString(str: string): string {
    let chars = str.split("");
    
    // Fisher-Yates Shuffle
    for (let i = chars.length() - 1; i > 0; i = i - 1) {
        let j = randomInt(0, i);
        let temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }
    
    return chars.join("");
}

// -------- API Endpoints --------

// Generiert ein Passwort mit Optionen
@POST("/api/password/generate")
fn generatePassword(options: PasswordOptions): GeneratedPassword {
    // Baue Zeichensatz
    let charset = "";
    
    if (options.includeUppercase) {
        charset = charset + getUppercase();
    }
    if (options.includeLowercase) {
        charset = charset + getLowercase();
    }
    if (options.includeNumbers) {
        charset = charset + getNumbers();
    }
    if (options.includeSymbols) {
        charset = charset + getSymbols();
    }
    
    if (charset.length() == 0) {
        throw ValidationError("Mindestens eine Zeichenart muss ausgewählt sein");
    }
    
    // Entferne ähnliche/mehrdeutige Zeichen
    if (options.excludeSimilar) {
        let similar = getSimilarChars();
        for (let i = 0; i < similar.length(); i = i + 1) {
            let char = similar.substring(i, i + 1);
            charset = charset.replace(char, "");
        }
    }
    
    if (options.excludeAmbiguous) {
        let ambiguous = getAmbiguousChars();
        for (let i = 0; i < ambiguous.length(); i = i + 1) {
            let char = ambiguous.substring(i, i + 1);
            charset = charset.replace(char, "");
        }
    }
    
    // Generiere Passwort
    let password = "";
    for (let i = 0; i < options.length; i = i + 1) {
        password = password + getRandomChar(charset);
    }
    
    // Stelle sicher, dass mind. ein Zeichen jeder gewählten Art vorhanden ist
    if (options.includeUppercase && !password.matches(".*[A-Z].*")) {
        let pos = randomInt(0, password.length() - 1);
        let replacement = getRandomChar(getUppercase());
        password = replaceCharAt(password, pos, replacement);
    }
    
    if (options.includeNumbers && !password.matches(".*[0-9].*")) {
        let pos = randomInt(0, password.length() - 1);
        let replacement = getRandomChar(getNumbers());
        password = replaceCharAt(password, pos, replacement);
    }
    
    if (options.includeSymbols && !password.matches(".*[^a-zA-Z0-9].*")) {
        let pos = randomInt(0, password.length() - 1);
        let replacement = getRandomChar(getSymbols());
        password = replaceCharAt(password, pos, replacement);
    }
    
    // Mische das Passwort
    password = shuffleString(password);
    
    // Prüfe Stärke
    let strength = checkPasswordStrength(password);
    let entropy = calculateEntropy(password, charset.length());
    
    return GeneratedPassword {
        password: password,
        strength: strength.level,
        score: strength.score,
        entropy: entropy,
        suggestions: strength.suggestions,
    };
}

// Generiert mehrere Passwörter
@POST("/api/password/generate-multiple")
fn generateMultiplePasswords(options: PasswordOptions, count: number): List<GeneratedPassword> {
    let passwords: List<GeneratedPassword> = [];
    
    for (let i = 0; i < count; i = i + 1) {
        passwords.push(generatePassword(options));
    }
    
    return passwords;
}

// Prüft Passwortstärke
@POST("/api/password/check-strength")
fn checkStrength(password: string): PasswordStrength {
    return checkPasswordStrength(password);
}

// Generiert eine einfache Passphrase aus Wörtern
@POST("/api/password/generate-passphrase")
fn generatePassphrase(wordCount: number, separator: string): GeneratedPassword {
    // Einfache Wortliste
    let words = [
        "tiger", "ocean", "mountain", "forest", "river",
        "sunset", "cloud", "star", "moon", "thunder",
        "winter", "summer", "spring", "autumn", "garden",
        "castle", "dragon", "knight", "wizard", "phoenix"
    ];
    
    let selectedWords: List<string> = [];
    
    for (let i = 0; i < wordCount; i = i + 1) {
        let index = randomInt(0, words.length() - 1);
        selectedWords.push(words[index]);
    }
    
    let passphrase = selectedWords.join(separator);
    let strength = checkPasswordStrength(passphrase);
    let entropy = calculateEntropy(passphrase, 20); // ~20 Wörter im Dictionary
    
    return GeneratedPassword {
        password: passphrase,
        strength: strength.level,
        score: strength.score,
        entropy: entropy,
        suggestions: strength.suggestions,
    };
}

// Generiert PIN
@POST("/api/password/generate-pin")
fn generatePin(length: number): string {
    let pin = "";
    
    for (let i = 0; i < length; i = i + 1) {
        pin = pin + getRandomChar(getNumbers());
    }
    
    return pin;
}

// Schätzt Zeit zum Cracken eines Passworts
@POST("/api/password/crack-time")
fn estimateCrackTime(password: string): string {
    let charsetSize = getCharsetSize(password);
    let combinations = pow(charsetSize, password.length());
    
    // Annahme: 1 Milliarde Versuche pro Sekunde
    let attemptsPerSecond = 1000000000;
    let seconds = combinations / attemptsPerSecond;
    
    if (seconds < 1) {
        return "Sofort";
    } else if (seconds < 60) {
        return "{seconds.round(0)} Sekunden";
    } else if (seconds < 3600) {
        return "{(seconds / 60).round(0)} Minuten";
    } else if (seconds < 86400) {
        return "{(seconds / 3600).round(0)} Stunden";
    } else if (seconds < 31536000) {
        return "{(seconds / 86400).round(0)} Tage";
    } else {
        return "{(seconds / 31536000).round(0)} Jahre";
    }
}

// Hilfsfunktionen
fn randomInt(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

fn replaceCharAt(str: string, pos: number, replacement: string): string {
    let before = str.substring(0, pos);
    let after = str.substring(pos + 1, str.length());
    return before + replacement + after;
}

fn log(x: number): number {
    return Math.log(x);
}

fn pow(base: number, exponent: number): number {
    return Math.pow(base, exponent);
}
